create table Client
(
    id        int primary key generated by default as identity,
    nickname  varchar not null,
    diskount1 float,
    diskount2 float
);

create table Product
(
    id               int primary key generated by default as identity,
    label            varchar not null,
    price            DECIMAL(10, 2) not null,
    current_diskount float
);

create table "Comment"
(
    id         int primary key generated by default as identity,
    client_id  int not null references Client(id),
    product_id int not null references  Product(id),
    rating     smallint check (rating between 1 and 5),
    review     text,
    constraint unique_client_product unique (client_id, product_id)
);

create table Sale
(
    cheque_num int       not null,
    client_id  int       not null references Client (id),
    date_sale  timestamp not null,
    primary key (date_sale, cheque_num)
);

-- Последовательность для номера чека
CREATE SEQUENCE IF NOT EXISTS check_num START 100;

--Функция генерации номера чека
CREATE OR REPLACE FUNCTION generate_check_number()
    RETURNS TRIGGER AS $$
DECLARE
    last_purchase_date DATE;
BEGIN
    -- Получаем дату последней покупки
    SELECT COALESCE(MAX(date_sale)::DATE, NEW.date_sale::DATE) INTO last_purchase_date FROM Sale;

    -- Если дата последней покупки отличается от текущей, сбрасываем последовательность
    IF last_purchase_date != NEW.date_sale::DATE THEN
        PERFORM setval('check_num', 100, false);
    END IF;

    -- Генерируем номер чека
    NEW.cheque_num := nextval('check_num');

    RETURN NEW;
END; $$ LANGUAGE plpgsql;

CREATE TRIGGER set_check_number
    BEFORE INSERT ON Sale
    FOR EACH ROW
EXECUTE FUNCTION generate_check_number();

create table ChequePos
(
    id             int primary key generated by default as identity,
    product_id     int references Product (id) not null,
    amount         int not null,
    price          decimal(10, 2) not null ,
    price_diskount decimal(10, 2),
    diskount       float,
    cheque_num     int not null,
    date_sale      timestamp not null,
    foreign key (cheque_num, date_sale) references Sale (cheque_num, date_sale)
);

-- Индексируем id то нет
CREATE INDEX sale_id
    ON ChequePos(cheque_num, date_sale);

-- Функция для формирования полей цены, скидки, и цены со скидкой в чеке
CREATE OR REPLACE FUNCTION calc_price()
    RETURNS TRIGGER AS $$
DECLARE
    disk_client DECIMAL(5, 2); disk_prod DECIMAL(5, 2); prod_price money;
BEGIN
    -- Формируем итоговую цену
    SELECT Product.price INTO prod_price FROM Product
    where NEW.product_id = Product.id;
    NEW.price = NEW.amount * prod_price;

    -- Выбираем скидку клиента
    IF NEW.amount >= 5 THEN
        SELECT Client.diskount2 INTO disk_client
        FROM Client, Sale
        where (Sale.cheque_num = NEW.cheque_num and NEW.date_sale = Sale.date_sale)
          and Sale.client_id = Client.id;
    ELSE
        SELECT Client.diskount1 INTO disk_client
        FROM Client, Sale
        where NEW.cheque_num = Sale.cheque_num and Sale.client_id = Client.id;
    END IF;

    IF disk_client = 0 THEN
        SELECT Client.diskount1 INTO disk_client
        FROM Client, Sale
        where NEW.cheque_num = Sale.cheque_num and Sale.client_id = Client.id;
    END IF;
    --

    -- Скидка на продукт
    SELECT current_diskount INTO disk_prod
    FROM Product
    where NEW.product_id = Product.id;

    IF (disk_prod + disk_client) > 18 THEN
        NEW.diskount := 0.18;
    ELSE
        NEW.diskount := (disk_prod + disk_client) / 100;
    END IF;

    -- Формируем итоговую цену
    IF NEW.diskount = 0 THEN
        NEW.price_diskount := NEW.price;
    ELSE
        NEW.price_diskount := NEW.diskount * NEW.price;
    END IF;

    RETURN NEW;
END; $$ LANGUAGE plpgsql;

CREATE TRIGGER set_price_insert
    BEFORE INSERT ON ChequePos
    FOR EACH ROW
EXECUTE FUNCTION calc_price();

CREATE TRIGGER set_price_update
    BEFORE INSERT ON ChequePos
    FOR EACH ROW
EXECUTE FUNCTION calc_price();